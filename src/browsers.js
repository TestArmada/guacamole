var Q = require("q");
var _ = require("lodash");
var request = require("request");
var syncRequest = require("sync-request");
var browsers = [];
var latest = {};
var fs = require("fs");
var path = require("path");

var cleanPlatformName = function (str) { return str.split(" ").join("_").split(".").join("_"); };

// SauceLabs leaves certain OSes out of its REST API, but these
// are configurable via the web-based platform configurator. The
// following are SauceLabs's internal substitutions for Windows OSes.
var OS_TRANSLATIONS = {
  "Windows XP":  "Windows 2003",     // Windows 2003 R2
  "Windows 7":   "Windows 2008",     // Windows 2008 R2
  "Windows 8":   "Windows 2012",     // Windows Server 2012
  "Windows 8.1": "Windows 2012 R2"   // Windows Server 2012 R2
};

var OS_TRANSLATIONS_FROM_ID = {};
Object.keys(OS_TRANSLATIONS).forEach(function (name) {
  OS_TRANSLATIONS_FROM_ID[cleanPlatformName(name)] = OS_TRANSLATIONS[name];
});

var SauceBrowsers = {

  CAPABILITY_FIELDS: [
    "browserName",          // i.e.: "firefox", "chrome", but also (strangely) "android"
    "version",              // i.e.: "42.0"

    "platform",             // i.e.: "OS X 10.10"
                            // NOTE:
                            // We perform some transformations from the listing API to 
                            // sauce's device capabilities API, i.e.: "Mac 10.10" -> "OS X 10.10".

    "deviceName",           // i.e: "Samsung Galaxy S5 Device".
                            // NOTE:
                            // As with platform, we transform some strings from the listing API
                            // on their way to the device capabilities API. For example, if the saucelabs
                            // listing API specifies a device field but does NOT have the word "device"
                            // in it, it's assumed to be an simulator, and we perform a transformation,
                            // i.e.: "iphone" -> "iPhone Simulator", "Mac <version>" -> "OS X <version>", etc.
                            // Some devices, like ones using android, have to use the long_name property

    "platformVersion",      // i.e.: "4.4"
    "platformName",         // i.e.: "Android"

    "screenResolution",     // i.e. "1024x768" or undefined. Generated by this module (if matched and requested)
    "deviceOrientation",    // i.e. "landscape" or undefined. Generated by this module (if matched and requested)
    "appium-version"
  ],

  INTERNAL_FIELDS: [
    "id",                   // Alias for a browser such as chrome_43_Windows_2012_R2_Desktop
    "family"                // For use in sorting or grouping browsers, i.e.: "IE", "Chrome", etc.
  ],

  // NOTE: The URL https://saucelabs.com/rest/v1/info/platforms/webdriver has this
  // information, but not the available resolutions. That's why we go to the endpoint 
  // with the much larger set of options (+ automation backends) and then filter down.
  SAUCE_URL: "https://saucelabs.com/rest/v1/info/platforms/all?resolutions=true",
  _haveCachedSauceBrowsers: false,

  filter: function (fn) {
    return browsers.filter(fn);
  },

  latest: latest,

  // Return a list of browser desiredCapabilities objects if they exist in our browser list.
  //
  // Match by:
  //
  // 1) id or family
  // 2) desiredCapabilities field values ( supported: browserName, version, platform, deviceName, platformVersion, platformName, screenResolution )
  //
  // Amend return object with:
  //
  // 1) A screenResolution, if specified, but only match browsers that support that screenResolution
  // 2) A deviceOrientation if specified, regardless of support.
  //
  // If wrapped is true, return a wrapper object within which a desiredCapabilities object can be found, along
  // with id, family, and a supported resolutions array (i.e. guacamole's raw internal representation)
  //
  get: function (specs, wrapped) {

    if (specs.id && specs.id.indexOf("latest") > -1) {
      var splitId = specs.id.split("latest");
      if (splitId.length === 2) {
        var browserId = splitId[0].replace("_", "");
        var osId = splitId[1].replace("_", "");
        if (latest[browserId] && latest[browserId][osId]) {
          var latestVersion = latest[browserId][osId];
          var newId = splitId[0] + latestVersion + splitId[1];
          specs.id = newId;
        }
      }
    }

    return browsers.filter(function (browser) {
      // Match specs. Ignore orientation, and special case screenResolution
      var matching = true;
      // Match by id (only if id has been specified)
      if (specs.id && browser.id !== specs.id) {
        var matchesTranslated = false;
        // Check if we've asked for a browser that isn't in the matrix, but would be if
        // SauceLabs had any of the OSes in OS_TRANSLATIONS.
        Object.keys(OS_TRANSLATIONS_FROM_ID).forEach(function (otherPlatformId) {
          // Check if the translated specs.id matches this browser
          var translatedPlatformName = OS_TRANSLATIONS_FROM_ID[otherPlatformId];
          if (browser.id === specs.id.replace(cleanPlatformName(otherPlatformId), cleanPlatformName(translatedPlatformName))) {
            matchesTranslated = true;
          }
        });
        if (matchesTranslated) {
          // pass through!
        } else {
          matching = false;
        }
      }

      // Match by family (only if family has been specified)
      if (specs.family && browser.family !== specs.family) {
        matching = false;
      }

      // If we've requested a screenResolution, disqualify this browser if it doesn't *explicitly* support it
      if (specs.screenResolution) {
        if (!browser.resolutions || browser.resolutions.indexOf(specs.screenResolution) === -1) {
          matching = false;
        }
      }

      // Match by properties from the desiredCapabilities object. Ignore certain field names.
      var ignoreFields = ["id", "family", "screenResolution", "deviceOrientation"];
      SauceBrowsers.CAPABILITY_FIELDS.forEach(function (field) {
        // Disqualify with a given field only if we've specified an explicit value for it
        if (ignoreFields.indexOf(field) === -1 && specs[field]) {
          // Special case: if we've specified platform, we check against the asked-for value,
          // but we also check against a translated value.
          if (field === "platform") {
            // If we're looking for an OS that has a weird name translation API-side,
            // allow a match to the translated version
            var translation = OS_TRANSLATIONS[specs[field]];
            if (browser.desiredCapabilities.platform !== translation
              && browser.desiredCapabilities.platform !== specs[field]) {
              matching = false;
            }
          } else {
            if (browser.desiredCapabilities[field] !== specs[field].toString()) {
              matching = false;
            }
          }
        }
      });

      return matching;
    }).map(function (browser) {
      var result;

      if (wrapped) {
        result = _.extend({}, browser);
      } else {
        result = _.extend({}, browser.desiredCapabilities);
      }

      if (specs.deviceOrientation) {
        if (wrapped) {
          result.desiredCapabilities.deviceOrientation = specs.deviceOrientation;
        } else {
          result.deviceOrientation = specs.deviceOrientation;
        }
      }

      if (specs.screenResolution) {
        if (wrapped) {
          result.desiredCapabilities.screenResolution = specs.screenResolution;
        } else {
          result.screenResolution = specs.screenResolution;
        }
      }
      
      // clean up capabilities here, only deal with saucelabs wrap here
      if (wrapped) {
        if(result.desiredCapabilities['appiumVersion'] || result.desiredCapabilities['appium-version']){
          // if using appium, use safari as browser for iOS
          if(result.desiredCapabilities.platformName === 'iOS'){
            result.desiredCapabilities.browserName = 'Safari';
          }
        }else{
          if(result.desiredCapabilities.platform === 'iOS'){
            // iOS is not platform name, use OS X 10.10 instead
            result.desiredCapabilities.platform = 'OS X 10.10';
          }else if(result.desiredCapabilities.platform === 'Android'){
            // Android is not platform name, use linux instead
            result.desiredCapabilities.platform = 'Linux';
          }
        }
      }
      
      return result;
    });
  },

  _normalize: function (data) {
    var result = data
      .filter(function (browser) {
        return browser.automation_backend === "webdriver"
          || browser.automation_backend === "appium";
      })
      .map(function (browser) {
        // Name and Family
        var name;

        if (browser.automation_backend === "appium") {
          if (browser.device.toLowerCase().indexOf("android") > -1) {
            name = "Android";
          } else if (browser.device.toLowerCase().indexOf("ipad") > -1) {
            name = "iOS";
          } else if (browser.device.toLowerCase().indexOf("iphone") > -1) {
            name = "iOS";
          } else {
            name = "Android";
          }

          if (browser.api_name.indexOf("android") > -1) {
            family = "Appium - Android";
          } else if (browser.api_name.indexOf("ipad") > -1) {
            family = "Appium - iPad";
          } else if (browser.api_name.indexOf("iphone") > -1) {
            family = "Appium - iPhone";
          } else {
            family = "Appium - Other";
          }
        } else {
          name = browser.api_name;

          if (name === "internet explorer") {
            name = "IE";
          }

          var family;
          if (name === "IE") {
            family = "IE";
          } else if (name.indexOf("android") === 0) {
            family = "Webkit Android";
          } else if (name.indexOf("firefox") === 0) {
            family = "Firefox (Gecko)";
          } else if (name.indexOf("ipad") === 0) {
            family = "Webkit iPad";
          } else if (name.indexOf("iphone") === 0) {
            family = "Webkit iPhone";
          } else if (name.indexOf("opera") === 0) {
            family = "Opera";
          } else if (name.indexOf("safari") === 0) {
            family = "Webkit Safari";
          } else if (name.indexOf("chrome") === 0) {
            family = "Chrome";
          } else {
            family = "Other";
          }
        }

        var deviceName;
        var osName;
        var hostOSName;

        // Device name, OS name, and the name of the "host" OS (i.e. a host OS for simulators)

        if (browser.automation_backend === "appium") {
          hostOSName = browser.os;

          if (name === "iOS") {
            deviceName = browser.long_name.split("p").join("P") + " Simulator";
          } else {
            deviceName = browser.long_name;
          }

          if (browser.device.toLowerCase().indexOf("android") > -1) {
            osName = "Android";
            hostOSName = "Android";
          } else if (browser.device.toLowerCase().indexOf("ipad") > -1) {
            osName = "iOS";
          } else if (browser.device.toLowerCase().indexOf("iphone") > -1) {
            osName = "iOS";
          } else {
            osName = "Android"; // some devices are named stuff like "Droid4", etc
          }

          if (hostOSName.indexOf("Mac") === 0) {
            hostOSName = hostOSName.replace("Mac", "OS X");
          }
        } else {
          // eg: device: "Nexus7C", long_name: "Google Nexus 7C Emulator"
          deviceName = (browser.device ? browser.long_name : "Desktop");
          osName = browser.os;

          // note: name comes from api_name
          if (name == "ipad") {
            osName = "iOS";
          } else if (name == "iphone") {
            osName = "iOS";
          } else if (name == "android") {
            osName = "Android";
          }

          if (osName.indexOf("Mac") === 0) {
            osName = osName.replace("Mac", "OS X");
          }
        }

        var guacamoleId;

        if (browser.automation_backend === "appium") {
          guacamoleId = (
            cleanPlatformName(deviceName)
            + "_" + cleanPlatformName(osName)
            + "_" + cleanPlatformName(browser.short_version)
            + "_" + cleanPlatformName(hostOSName)
          )
        } else {
          var osKey = cleanPlatformName(osName) + "_" + cleanPlatformName(deviceName);
          guacamoleId = (
            cleanPlatformName(name)
            + "_" + cleanPlatformName(browser.short_version)
            + "_" + osKey
          );

          if (!latest[browser.api_name]) {
            latest[browser.api_name] = {};
          }

          if(!latest[browser.api_name][osKey] || latest[browser.api_name][osKey] < browser.short_version) {
            latest[browser.api_name][osKey] = parseInt(browser.short_version, 10);
          }
        }

        var result = {
          // name , version, OS, device
          id: guacamoleId,
          platform: osName,
          family: family,
          resolutions: browser.resolutions
        };

        if (browser.automation_backend === "appium") {
          result["appium-version"] = browser.recommended_backend_version;
          result.platformVersion = browser.short_version;

          if (deviceName.toLowerCase().indexOf("android") > -1) {
            result.platformName = osName;
          } else if (deviceName.toLowerCase().indexOf("ipad") > -1) {
            result.platformName = osName;
          } else if (deviceName.toLowerCase().indexOf("iphone") > -1) {
            result.platformName = osName;
          }
        } else {

          result.browserName = browser.api_name;
          result.version = browser.short_version;

          if (deviceName.toLowerCase().indexOf("android") > -1) {
            result.platformVersion = browser.short_version || browser.version;
            result.platformName = osName;
          }
        }

        // Note: we only set the device property if we have a non-desktop device. This is because
        // SauceLabs doesn't actually have a "Desktop" device, we're just making one up for UX.
        if (deviceName !== "Desktop") {
          // this is a mobile device as opposed to a desktop browser.
          result.deviceName = deviceName;
        }

        return result;
      }).map(function (browser) {
        var result = {
          id: browser.id,
          family: browser.family,
          resolutions: browser.resolutions,
          desiredCapabilities: {}
        };

        SauceBrowsers.CAPABILITY_FIELDS.forEach(function (field) {
          if (browser[field]) {
            result.desiredCapabilities[field] = browser[field];
          }
        });

        return result;
      });

    return _.sortBy(result, function (browser) { return browser.id; });
  },

  // Fetch a raw list of browsers from the Sauce API
  _fetch: function () {
    var deferred = Q.defer();

    request(this.SAUCE_URL, function (err, data) {
      if (err) {
        deferred.reject(err);
      } else {
        try {
          data = JSON.parse(data.body);
        } catch (e) {
          deferred.reject(e);
          return;
        }
        deferred.resolve(data);
      }
    });

    return deferred.promise;
  },

  _fetchSync: function () {
    var res = syncRequest("GET", this.SAUCE_URL);
    var data;
    try {
      data = JSON.parse(res.getBody("utf8"));
    } catch (e) {
      throw new Error("Could not fetch saucelabs browsers from " + this.SAUCE_URL);
    }
    return data;
  },

  // Signal that we want to load a shrinkwrap file (i.e. cached sauce labs API result) and bypass the Sauce API
  useShrinkwrap: function (shrinkwrapFilepath) {
    shrinkwrapFilepath = path.resolve(shrinkwrapFilepath || "./guacamole-shrinkwrap.json");
    try {
      var data = JSON.parse(fs.readFileSync(shrinkwrapFilepath, "utf8"));
      if (data) {
        this._haveCachedSauceBrowsers = true;
        browsers = this._normalize(data);
      }
    } catch (e) {
      throw new Error("Could not read guacamole shrinkwrap file at : " + shrinkwrapFilepath);
    }
  },

  useServiceSync: function () {
    var data = this._fetchSync();
    if (data) {
      this._haveCachedSauceBrowsers = true;
      browsers = this._normalize(data);
    }
  },

  addNormalizedBrowsersFromFile: function (filePath) {
    var self = this;
    filePath = path.resolve(filePath);
    try {
      var data = JSON.parse(fs.readFileSync(filePath, "utf8"));
      if (_.isArray(data)) {
        data.forEach(function (normalizedBrowser) {
          browsers.push(normalizedBrowser);
        });
      }
    } catch (e) {
      throw new Error("Could not read file for additional devices/browsers at : " + filePath);
    }
  },

  // Return a promise that we'll build a list of supported browsers
  initialize: function () {
    var deferred = Q.defer();
    var self = this;

    if (this._haveCachedSauceBrowsers) {
      deferred.resolve();
      return deferred.promise;
    }

    this._fetch()
      .then(function (data) {
        self._haveCachedSauceBrowsers = true;
        browsers = self._normalize(data);

        deferred.resolve();
      })
      .catch(function (err) {
        deferred.reject(err);
      });

    return deferred.promise;
  }
};

SauceBrowsers._normalize = SauceBrowsers._normalize.bind(SauceBrowsers);

module.exports = SauceBrowsers;